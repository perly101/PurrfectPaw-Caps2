//php artisan serve --host=0.0.0.0 --port=8000

import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Alert } from 'react-native';

// Define multiple possible API base URLs
const API_BASE_URLS = [
  'https://supehdah.amelia00dawn.com/api', // Production server
  'http://192.168.1.4:8000/api', // Local development network
  'http://10.0.2.2:8000/api'     // Android emulator to localhost
];

// Use the production URL for the APK build
const API_BASE_URL = API_BASE_URLS[0];

// Create API instance with our fixed URL
export const API = axios.create({
  baseURL: API_BASE_URL,
  headers: { 
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  timeout: 15000 // 15 seconds timeout
});

// Log the initialized API URL
console.log(`Initialized API with fixed base URL: ${API.defaults.baseURL}`);

// Global navigation reference to allow programmatic navigation outside components
let navigationRef: any = null;

// Function to set the navigation reference from App.tsx
export const setNavigationRef = (ref: any) => {
  navigationRef = ref;
};

// Auth failure prevention 
let authFailureHandled = false;
let lastAuthFailureTime = 0;
const AUTH_FAILURE_COOLDOWN = 5000; // 5 seconds

// Try to refresh the auth token
export const attemptTokenRefresh = async (): Promise<boolean> => {
  console.log('üîÑ Attempting to refresh auth token...');
  
  try {
    // Check if we have a refresh token
    const refreshToken = await AsyncStorage.getItem('refreshToken');
    if (!refreshToken) {
      console.log('‚ùå No refresh token available');
      return false;
    }
    
    // Create a new axios instance for the refresh request to avoid interceptors
    const refreshAPI = axios.create({
      baseURL: API_BASE_URL,
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      timeout: 10000
    });
    
    // Try to refresh the token
    const response = await refreshAPI.post('/refresh-token', { refresh_token: refreshToken });
    
    if (response.data && response.data.token) {
      console.log('‚úÖ Token refresh successful');
      
      // Save the new tokens
      await AsyncStorage.setItem('token', response.data.token);
      await AsyncStorage.setItem('accessToken', response.data.token);
      
      if (response.data.refresh_token) {
        await AsyncStorage.setItem('refreshToken', response.data.refresh_token);
      }
      
      return true;
    }
    
    console.log('‚ùå Token refresh failed - invalid response');
    return false;
  } catch (error) {
    console.log('‚ùå Token refresh failed with error:', error);
    return false;
  }
};

// Function to handle logout and redirect to login
export const handleAuthFailure = async () => {
  const now = Date.now();
  
  // Check if we've handled an auth failure recently to avoid spamming the user
  if (authFailureHandled && (now - lastAuthFailureTime < AUTH_FAILURE_COOLDOWN)) {
    console.log('üîÑ Auth failure already being handled, skipping duplicate');
    return;
  }
  
  // Set flags to prevent duplicate handling
  authFailureHandled = true;
  lastAuthFailureTime = now;
  
  // Check current screen to avoid unnecessary redirects
  let currentScreen = 'unknown';
  if (navigationRef && navigationRef.getCurrentRoute) {
    try {
      currentScreen = navigationRef.getCurrentRoute()?.name || 'unknown';
      if (currentScreen === 'Login' || currentScreen === 'OTPVerification') {
        console.log(`üîÑ Already on ${currentScreen} screen, aborting auth failure handling`);
        setTimeout(() => {
          authFailureHandled = false;
        }, AUTH_FAILURE_COOLDOWN);
        return;
      }
    } catch (e) {
      console.error('Error getting current route:', e);
    }
  }
  
  // Try token refresh before logging out
  const refreshed = await attemptTokenRefresh();
  if (refreshed) {
    console.log('üîÑ Token refreshed successfully, not logging out');
    setTimeout(() => {
      authFailureHandled = false; // Reset the flag after some time
    }, AUTH_FAILURE_COOLDOWN);
    return;
  }
  
  console.log('üîë Auth token expired or invalid, logging out...');
  
  // Check if we're in a verification flow
  const inVerificationFlow = await AsyncStorage.getItem('verification_flow') === 'true';
  
  // Clear token and any user data from storage
  try {
    await AsyncStorage.removeItem('token');
    await AsyncStorage.removeItem('userToken');
    await AsyncStorage.removeItem('accessToken');
    await AsyncStorage.removeItem('refreshToken');
    await AsyncStorage.removeItem('user');
    console.log('üßπ Cleared auth tokens and user data');
  } catch (e) {
    console.error('Error clearing auth data:', e);
  }
  
  setTimeout(() => {
    authFailureHandled = false; // Reset the flag after some time
  }, AUTH_FAILURE_COOLDOWN);
  
  // Redirect to login screen if navigation is available
  if (navigationRef) {
    console.log('üîÑ Redirecting to login screen');
    
    // Use reset navigation to go to login
    navigationRef.reset({
      index: 0,
      routes: [{ name: 'Login' }],
    });
    
    // Different message based on verification flow
    if (inVerificationFlow) {
      setTimeout(() => {
        Alert.alert(
          'Verification Session Expired',
          'Your verification session has expired. Please log in again to continue verification.',
          [{ text: 'OK' }]
        );
      }, 500);
    } else {
      setTimeout(() => {
        Alert.alert(
          'Session Expired',
          'Your session has expired. Please log in again.',
          [{ text: 'OK' }]
        );
      }, 500);
    }
  } else {
    console.error('‚ùå Navigation reference not set, cannot redirect to login');
  }
};

// Track request timestamps to prevent excessive requests
const requestTimestamps: { [key: string]: number } = {};
const MIN_REQUEST_INTERVAL = 2000; // 2 seconds

// Track auth-related requests to prevent infinite loops
let loginRequestInProgress = false;

// Automatically attach token to every request
API.interceptors.request.use(async (config) => {
  // Track login requests to prevent infinite loops
  if (config.url?.includes('/login')) {
    loginRequestInProgress = true;
  }

  // Rate limiting for same endpoint
  const requestKey = `${config.method}-${config.url}`;
  const lastRequestTime = requestTimestamps[requestKey] || 0;
  const now = Date.now();
  
  // If this is a repeated request too soon, block it unless it's a critical endpoint
  if (now - lastRequestTime < MIN_REQUEST_INTERVAL && 
      !config.url?.includes('login') && 
      !config.url?.includes('register')) {
    console.log(`‚ö†Ô∏è Blocking too frequent request to ${requestKey}`);
    return Promise.reject({
      message: 'Too many requests, please wait',
      config,
      response: { status: 429 }
    });
  }
  
  // Update the timestamp for this request
  requestTimestamps[requestKey] = now;
  
  // Get auth token
  const token = await AsyncStorage.getItem('token') || 
                await AsyncStorage.getItem('userToken') || 
                await AsyncStorage.getItem('accessToken');
  
  // For debugging current navigation state
  let currentScreen = 'unknown';
  if (navigationRef && navigationRef.getCurrentRoute) {
    try {
      currentScreen = navigationRef.getCurrentRoute()?.name || 'unknown';
      console.log(`üß≠ Current navigation screen: ${currentScreen}`);
    } catch (e) {
      console.error('Error getting current route:', e);
    }
  }
  
  // Only attach token and make requests requiring auth if we have a token
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
    console.log("üîë Token attached to request");
  } else {
    // Skip token checks if we're on login or registration screens
    if (currentScreen === 'Login' || currentScreen === 'Register' || currentScreen === 'OTPVerification') {
      console.log(`üîÑ On ${currentScreen} screen, proceeding without token`);
      return config;
    }
    
    // If this is an authenticated endpoint and we have no token,
    // don't even make the request to prevent 401 errors
    if (config.url && 
        (config.url.includes('/me') || 
         config.url.includes('/user') || 
         config.url.includes('/pets') ||
         config.url.includes('/verify-otp') ||
         config.url.includes('/resend-otp'))) {
      console.log(`üõë Blocking auth request to ${config.url} - no token available`);
      
      // Only trigger auth failure if we're not already on login screen
      if (currentScreen !== 'Login' && currentScreen !== 'Register') {
        console.log('üîÑ No token for auth request, redirecting to login');
        setTimeout(() => handleAuthFailure(), 0);
      }
      
      return Promise.reject({
        message: 'Authentication required',
        config,
        response: { status: 401 }
      });
    }
    console.log("‚ö†Ô∏è No token found for request");
  }
  
  return config;
});

// Response interceptor to handle auth errors
API.interceptors.response.use(
  (response) => {
    // Check if this was a successful login request
    if (response.config.url?.includes('/login') && response.status === 200) {
      loginRequestInProgress = false;
    }
    return response;
  },
  async (error) => {
    // Don't handle errors that we created in the request interceptor
    if (error.config === undefined) {
      return Promise.reject(error);
    }
    
    // Special handling for login-related requests
    const isLoginRequest = error.config.url?.includes('/login');
    if (isLoginRequest) {
      loginRequestInProgress = false;
      return Promise.reject(error);
    }
    
    // Handle rate limiting errors (429)
    if (error.response && error.response.status === 429) {
      console.log('‚è≥ Rate limited - too many requests');
      // Don't redirect to login for rate limiting
      return Promise.reject(error);
    }
    
    // Check if the error is due to an expired/invalid token (401 Unauthorized)
    if (error.response && error.response.status === 401) {
      console.log('üö´ Received 401 Unauthorized response');
      
      // Skip auth failure handling if we're already processing login
      if (loginRequestInProgress) {
        console.log('üîÑ Login already in progress, skipping auth failure handling');
        return Promise.reject(error);
      }
      
      // Get the current screen from navigation if available
      let currentScreen = 'unknown';
      if (navigationRef && navigationRef.getCurrentRoute) {
        try {
          currentScreen = navigationRef.getCurrentRoute()?.name || 'unknown';
        } catch (e) {
          console.error('Error getting current route:', e);
        }
      }
      
      // Skip auth failure handling if we're already on login or OTP verification screen
      if (currentScreen === 'Login' || currentScreen === 'OTPVerification') {
        console.log(`üîÑ Already on ${currentScreen} screen, skipping auth failure handling`);
        return Promise.reject(error);
      }
      
      // Handle authentication failure
      await handleAuthFailure();
      return Promise.reject(error);
    }
    
    // For other errors, just pass through
    return Promise.reject(error);
  }
);

// Helper to create authenticated request headers
export const getAuthHeaders = async () => {
  const token = await AsyncStorage.getItem('token') || 
                await AsyncStorage.getItem('userToken') || 
                await AsyncStorage.getItem('accessToken');
  
  if (!token) {
    console.warn('No auth token available for headers');
    return { 'Content-Type': 'application/json', 'Accept': 'application/json' };
  }
  
  return {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  };
};
